// src/lib/pluginManager.ts
import { LanguagePlugin, FileMap, ValidationResult, PluginRegistry } from '@/types/plugin';
import { TreeNode } from '@/types/fileTree';
import { ProjectSettings } from '@/types/project';

class PluginManager {
  private plugins: PluginRegistry = {};
  private initialized = false;

  async initialize() {
    if (this.initialized) return;
    
    // Auto-register built-in plugins
    const builtInPlugins = await this.loadBuiltInPlugins();
    builtInPlugins.forEach(plugin => this.register(plugin));
    
    this.initialized = true;
  }

  register(plugin: LanguagePlugin): void {
    if (this.plugins[plugin.id]) {
      console.warn(`Plugin ${plugin.id} already registered, overwriting...`);
    }
    
    // Validate plugin structure
    if (!this.validatePlugin(plugin)) {
      throw new Error(`Invalid plugin: ${plugin.id}`);
    }
    
    this.plugins[plugin.id] = plugin;
  }

  unregister(pluginId: string): boolean {
    if (this.plugins[pluginId]) {
      delete this.plugins[pluginId];
      return true;
    }
    return false;
  }

  getPlugin(pluginId: string): LanguagePlugin | undefined {
    return this.plugins[pluginId];
  }

  getAllPlugins(): LanguagePlugin[] {
    return Object.values(this.plugins);
  }

  getPluginsByCategory(category: LanguagePlugin['category']): LanguagePlugin[] {
    return this.getAllPlugins().filter(plugin => plugin.category === category);
  }

  getPluginForFile(filename: string): LanguagePlugin | undefined {
    const extension = this.getFileExtension(filename);
    return this.getAllPlugins().find(plugin => 
      plugin.extensions.includes(extension)
    );
  }

  generateContent(filename: string, settings: ProjectSettings): string {
    const plugin = this.getPluginForFile(filename);
    if (plugin) {
      return plugin.generateContent(filename, settings);
    }
    
    // Fallback to generic content
    return this.generateGenericContent(filename);
  }

  processTree(tree: TreeNode, settings: ProjectSettings): TreeNode {
    let processedTree = { ...tree };
    
    // Apply beforeGeneration hooks
    this.getAllPlugins().forEach(plugin => {
      if (plugin.hooks?.beforeGeneration) {
        processedTree = plugin.hooks.beforeGeneration(processedTree, settings);
      }
    });
    
    return processedTree;
  }

  processFiles(files: FileMap, settings: ProjectSettings): FileMap {
    let processedFiles = { ...files };
    
    // Apply afterGeneration hooks
    this.getAllPlugins().forEach(plugin => {
      if (plugin.hooks?.afterGeneration) {
        processedFiles = plugin.hooks.afterGeneration(processedFiles, settings);
      }
    });
    
    return processedFiles;
  }

  validateTree(tree: TreeNode): ValidationResult {
    const results: ValidationResult[] = [];
    
    this.getAllPlugins().forEach(plugin => {
      if (plugin.hooks?.customValidation) {
        results.push(plugin.hooks.customValidation(tree));
      }
    });
    
    return this.mergeValidationResults(results);
  }

  getSampleTrees(): Array<{ plugin: LanguagePlugin; tree: string }> {
    return this.getAllPlugins().map(plugin => ({
      plugin,
      tree: plugin.sampleTree
    }));
  }

  private async loadBuiltInPlugins(): Promise<LanguagePlugin[]> {
    // Dynamic imports for built-in plugins
    const [
      nextjsPlugin,
      reactPlugin,
      pythonPlugin,
      nodePlugin,
      goPlugin,
      rustPlugin,
      vuePlugin
    ] = await Promise.all([
      import('./plugins/nextjs').then(m => m.default),
      import('./plugins/react').then(m => m.default),
      import('./plugins/python').then(m => m.default),
      import('./plugins/node').then(m => m.default),
      import('./plugins/go').then(m => m.default),
      import('./plugins/rust').then(m => m.default),
      import('./plugins/vue').then(m => m.default),
    ]);

    return [
      nextjsPlugin,
      reactPlugin,
      pythonPlugin,
      nodePlugin,
      goPlugin,
      rustPlugin,
      vuePlugin
    ];
  }

  private validatePlugin(plugin: LanguagePlugin): boolean {
    return !!(
      plugin.id &&
      plugin.name &&
      plugin.extensions?.length &&
      plugin.generateContent &&
      plugin.sampleTree
    );
  }

  private getFileExtension(filename: string): string {
    const parts = filename.split('.');
    return parts.length > 1 ? `.${parts.pop()}` : '';
  }

  private generateGenericContent(filename: string): string {
    if (filename.startsWith('.')) {
      return `# ${filename} configuration file\n`;
    }
    return `// ${filename}\n// Generated by File Tree Generator\n`;
  }

  private mergeValidationResults(results: ValidationResult[]): ValidationResult {
    return {
      valid: results.every(r => r.valid),
      errors: results.flatMap(r => r.errors),
      warnings: results.flatMap(r => r.warnings)
    };
  }
}

// Singleton instance
export const pluginManager = new PluginManager();
